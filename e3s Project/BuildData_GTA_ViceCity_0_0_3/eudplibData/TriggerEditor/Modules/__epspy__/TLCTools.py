## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.core.eudfunc import EUDTraceLog, EUDTracedFunc, EUDTracedTypedFunc, EUDTracedMethod, EUDTracedTypedMethod
from eudplib.epscript.helper import _RELIMP, _TYGV, _TYSV, _TYLV, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LSH, _ALL
# (Line 1) import PluginVariables as msqcvar;
import PluginVariables as msqcvar
# (Line 2) import TriggerEditor.TETools as tt;
from TriggerEditor import TETools as tt
# (Line 3) import Modules.GTAintro;
from Modules import GTAintro
# (Line 5) const baseX=256;
baseX = _CGFW(lambda: [256], 1)[0]
# (Line 7) var movementLoop;
movementLoop = EUDVariable()
# (Line 9) const civX = [6544,6896,7024,6928,6576,6448,6416,7056,7216,
# (Line 10) 6992,6896,6736,6576,];
civX = _CGFW(lambda: [_ARR(FlattenList([6544, 6896, 7024, 6928, 6576, 6448, 6416, 7056, 7216, 6992, 6896, 6736, 6576]))], 1)[0]
# (Line 11) const civY = [1520,1040,912  ,1520,1040,912  ,1520,1520,1712,
# (Line 12) 1712,1712,1712,1744,];
civY = _CGFW(lambda: [_ARR(FlattenList([1520, 1040, 912, 1520, 1040, 912, 1520, 1520, 1712, 1712, 1712, 1712, 1744]))], 1)[0]
# (Line 15) const moveOptX =	  [6416,6928,6576,6576,
# (Line 16) 6576,7024,7024,6928,
# (Line 17) 6448,6896,6896,7056,
# (Line 18) 6544,7056,6896,6896,
# (Line 19) 6448,6896,6448,6544,
# (Line 20) 6576,7024,6576,6416,
# (Line 21) 6288,6544,6448,6288,
# (Line 22) 6928,7216,7024,7216,
# (Line 23) 6992,7216,7056,7216,
# (Line 24) 6896,7216,7056,6992,
# (Line 25) 6736,6992,6928,6896,
# (Line 26) 6576,6896,6576,6736,
# (Line 27) 6384,6736,6544,6576,
# (Line 28) ];
moveOptX = _CGFW(lambda: [_ARR(FlattenList([6416, 6928, 6576, 6576, 6576, 7024, 7024, 6928, 6448, 6896, 6896, 7056, 6544, 7056, 6896, 6896, 6448, 6896, 6448, 6544, 6576, 7024, 6576, 6416, 6288, 6544, 6448, 6288, 6928, 7216, 7024, 7216, 6992, 7216, 7056, 7216, 6896, 7216, 7056, 6992, 6736, 6992, 6928, 6896, 6576, 6896, 6576, 6736, 6384, 6736, 6544, 6576]))], 1)[0]
# (Line 29) const moveOptY =	  [1520,1520,1040,1744,
# (Line 30) 1040,912  ,912  ,1520,
# (Line 31) 912  ,1040,1040,1520,
# (Line 32) 1520,1520,1040,1712,
# (Line 33) 912  ,1040,912  ,1520,
# (Line 34) 1040,912  ,1040,1520,
# (Line 35) 1520,1520,912  ,1520,
# (Line 36) 1520,1712,912  ,1712,
# (Line 37) 1712,2512,1520,2512,
# (Line 38) 1712,1712,1520,1968,
# (Line 39) 1712,1712,1520,1968,
# (Line 40) 1744,1712,1744,1936,
# (Line 41) 1760,1712,1520,1936,
# (Line 42) ];
moveOptY = _CGFW(lambda: [_ARR(FlattenList([1520, 1520, 1040, 1744, 1040, 912, 912, 1520, 912, 1040, 1040, 1520, 1520, 1520, 1040, 1712, 912, 1040, 912, 1520, 1040, 912, 1040, 1520, 1520, 1520, 912, 1520, 1520, 1712, 912, 1712, 1712, 2512, 1520, 2512, 1712, 1712, 1520, 1968, 1712, 1712, 1520, 1968, 1744, 1712, 1744, 1936, 1760, 1712, 1520, 1936]))], 1)[0]
# (Line 44) const buildingID =     [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,];
buildingID = _CGFW(lambda: [_ARR(FlattenList([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]))], 1)[0]
# (Line 45) const buildingX =       [0,6624,4240,4320,3520,5728,6928,3952,5616,4352,2752,2080,4672,6784,6752,4000,3552,3888,4656,7088,6480,6128,5136,6128,6224,6000,6096,5872,3984,3792,3888,];
buildingX = _CGFW(lambda: [_ARR(FlattenList([0, 6624, 4240, 4320, 3520, 5728, 6928, 3952, 5616, 4352, 2752, 2080, 4672, 6784, 6752, 4000, 3552, 3888, 4656, 7088, 6480, 6128, 5136, 6128, 6224, 6000, 6096, 5872, 3984, 3792, 3888]))], 1)[0]
# (Line 46) const buildingY =       [0,1456,1248,976  ,2736,6576,2176,4704,5824,1936,4752,6096,1936,3056,4720,4976,5520,800  ,2400,896  ,2368,3040,4736,5440,6144,6944,2784,5952,4160,5408,6368,];
buildingY = _CGFW(lambda: [_ARR(FlattenList([0, 1456, 1248, 976, 2736, 6576, 2176, 4704, 5824, 1936, 4752, 6096, 1936, 3056, 4720, 4976, 5520, 800, 2400, 896, 2368, 3040, 4736, 5440, 6144, 6944, 2784, 5952, 4160, 5408, 6368]))], 1)[0]
# (Line 47) const buildingExitX = [0,6624,4240,4320,3520,5728,6928,3952,5616,4352,2752,2160,4672,6784,6752,4000,3552,3888,4656,7088,6480,6128,5136,6128,6224,6000,6096,5872,3984,3792,3888,];
buildingExitX = _CGFW(lambda: [_ARR(FlattenList([0, 6624, 4240, 4320, 3520, 5728, 6928, 3952, 5616, 4352, 2752, 2160, 4672, 6784, 6752, 4000, 3552, 3888, 4656, 7088, 6480, 6128, 5136, 6128, 6224, 6000, 6096, 5872, 3984, 3792, 3888]))], 1)[0]
# (Line 48) const buildingExitY = [0,1520,1200,1040,2800,6640,2224,4656,5872,2000,4816,6096,2000,3120,4784,5040,5584,848  ,2448,944  ,2416,3088,4688,5488,6096,6992,2736,5904,4208,5360,6416,];
buildingExitY = _CGFW(lambda: [_ARR(FlattenList([0, 1520, 1200, 1040, 2800, 6640, 2224, 4656, 5872, 2000, 4816, 6096, 2000, 3120, 4784, 5040, 5584, 848, 2448, 944, 2416, 3088, 4688, 5488, 6096, 6992, 2736, 5904, 4208, 5360, 6416]))], 1)[0]
# (Line 49) const buildingType =  [0,1,2,1,1,1,2,2,2,3,3,3,4,4,4,4,4,5,5,5,5,5,5,5,5,5,6,6,6,6,6,];//0 none, 1 ammonation, 2 hospital, 3 fire station, 4 police, 5 safehouse, 6 paint shop
buildingType = _CGFW(lambda: [_ARR(FlattenList([0, 1, 2, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6]))], 1)[0]
# (Line 50) const buildingUnit =   [0,111,112,111,111,111,112,112,112,113,113,113,106,106,106,106,106,125,125,125,125,125,125,125,125,125,109,109,109,109,109,];
buildingUnit = _CGFW(lambda: [_ARR(FlattenList([0, 111, 112, 111, 111, 111, 112, 112, 112, 113, 113, 113, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 125, 125, 109, 109, 109, 109, 109]))], 1)[0]
# (Line 51) const buildingColor = [0,1,5,7,3,6,0,2,4,1,5,7,3,6,0,2,4,1,5,7,3,6,0,2,4,1,5,7,3,6,0,];
buildingColor = _CGFW(lambda: [_ARR(FlattenList([0, 1, 5, 7, 3, 6, 0, 2, 4, 1, 5, 7, 3, 6, 0, 2, 4, 1, 5, 7, 3, 6, 0, 2, 4, 1, 5, 7, 3, 6, 0]))], 1)[0]
# (Line 53) const carX = [0];
carX = _CGFW(lambda: [_ARR(FlattenList([0]))], 1)[0]
# (Line 54) const carY = [0];
carY = _CGFW(lambda: [_ARR(FlattenList([0]))], 1)[0]
# (Line 55) const carMoveX = [0];
carMoveX = _CGFW(lambda: [_ARR(FlattenList([0]))], 1)[0]
# (Line 56) const carMoveY = [0];
carMoveY = _CGFW(lambda: [_ARR(FlattenList([0]))], 1)[0]
# (Line 58) const loadedInteriors = [0,0,0,0,0,0];
loadedInteriors = _CGFW(lambda: [_ARR(FlattenList([0, 0, 0, 0, 0, 0]))], 1)[0]
# (Line 59) const playerCurrentBuild = [0,0,0,0,0,0];
playerCurrentBuild = _CGFW(lambda: [_ARR(FlattenList([0, 0, 0, 0, 0, 0]))], 1)[0]
# (Line 61) function calculateDistance(x1, y1, x2, y2) {
@EUDFunc
def f_calculateDistance(x1, y1, x2, y2):
    # (Line 62) const dx = x2 - x1;
    dx = x2 - x1
    # (Line 63) const dy = y2 - y1;
    dy = y2 - y1
    # (Line 64) return dx*dx + dy*dy;
    EUDReturn(dx * dx + dy * dy)
    # (Line 65) }
    # (Line 67) function forceSelect(player,ptr){

@EUDFunc
def f_forceSelect(player, ptr):
    # (Line 68) setcurpl(player);
    f_setcurpl(player)
    # (Line 69) dwwrite(0x6284B8,ptr);
    f_dwwrite(0x6284B8, ptr)
    # (Line 70) dwwrite(0x6284E8 + 48 * player,ptr);
    f_dwwrite(0x6284E8 + 48 * player, ptr)
    # (Line 71) dwwrite(0x597208,ptr);
    f_dwwrite(0x597208, ptr)
    # (Line 72) dwwrite(0x59723C,1);
    f_dwwrite(0x59723C, 1)
    # (Line 73) }
    # (Line 75) function checkInterior(buildingID){

@EUDFunc
def f_checkInterior(buildingID_1):
    # (Line 76) var firstEmpty = 999;
    firstEmpty = _TYLV([None], [999])
    # (Line 77) for(var i=0;i<loadedInteriors.length;i++){
    i = _TYLV([None], [0])
    if EUDWhile()(i >= loadedInteriors.length, neg=True):
        def _t2():
            i.__iadd__(1)
        # (Line 78) if(loadedInteriors[i] == buildingID){
        if EUDIf()(_ARRC(loadedInteriors, i) == buildingID_1):
            # (Line 79) return i;
            EUDReturn(i)
            # (Line 80) }
            # (Line 81) if(loadedInteriors[i]==0 && firstEmpty==999){
        EUDEndIf()
        if EUDIf()(EUDSCAnd()(_ARRC(loadedInteriors, i) == 0)(firstEmpty == 999)()):
            # (Line 82) firstEmpty = i;
            firstEmpty << (i)
            # (Line 83) }
            # (Line 84) }
        EUDEndIf()
        # (Line 85) return firstEmpty;
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    EUDReturn(firstEmpty)
    # (Line 86) }
    # (Line 88) function clearInterior(interior){

@EUDFunc
def f_clearInterior(interior):
    # (Line 89) for(var i=0;i<loadedInteriors.length;i++){
    i = _TYLV([None], [0])
    if EUDWhile()(i >= loadedInteriors.length, neg=True):
        def _t2():
            i.__iadd__(1)
        # (Line 90) if(loadedInteriors[i] == interior){
        if EUDIf()(_ARRC(loadedInteriors, i) == interior):
            # (Line 91) loadedInteriors[i] = 0;
            _ARRW(loadedInteriors, i) << (0)
            # (Line 92) setloc(198,256,3232+(768*i),256+1568,3232+(768*i)+704);
            f_setloc(198, 256, 3232 + (768 * i), 256 + 1568, 3232 + (768 * i) + 704)
            # (Line 93) RemoveUnitAt(All,229,198,AllPlayers);
            # (Line 94) break;
            DoActions(RemoveUnitAt(All, 229, 198, AllPlayers))
            EUDBreak()
            # (Line 95) }
            # (Line 96) }
        EUDEndIf()
        # (Line 97) }
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    # (Line 99) function randNum(maxNumber){

@EUDFunc
def f_randNum(maxNumber):
    # (Line 100) return rand() * (maxNumber+1) / 65536;
    EUDReturn(f_rand() * (maxNumber + 1) // 65536)
    # (Line 101) }
    # (Line 103) function runAI(){

@EUDFunc
def f_runAI():
    # (Line 104) if(!getgametick()%12){
    if EUDIf()(f_getgametick() % 12, neg=True):
        # (Line 105) if(movementLoop==civX.length){
        if EUDIf()(movementLoop == civX.length):
            # (Line 106) movementLoop=0;
            movementLoop << (0)
            # (Line 107) }
            # (Line 108) if(GTAintro.civSpawned[movementLoop]>0){
        EUDEndIf()
        if EUDIf()(_ARRC(GTAintro.civSpawned, movementLoop) <= 0, neg=True):
            # (Line 109) setloc(190,civX[movementLoop]-16,civY[movementLoop]-16,civX[movementLoop]+16,civY[movementLoop]+16);
            f_setloc(190, civX[movementLoop] - 16, civY[movementLoop] - 16, civX[movementLoop] + 16, civY[movementLoop] + 16)
            # (Line 110) const randomDirection=randNum(3);
            randomDirection = f_randNum(3)
            # (Line 111) setloc(191,moveOptX[(movementLoop*4)+randomDirection],moveOptY[(movementLoop*4)+randomDirection]);
            f_setloc(191, moveOptX[(movementLoop * 4) + randomDirection], moveOptY[(movementLoop * 4) + randomDirection])
            # (Line 112) Order(15,6,190,Move,191);
            # (Line 113) }
            DoActions(Order(15, 6, 190, Move, 191))
            # (Line 114) movementLoop++;
        EUDEndIf()
        movementLoop.__iadd__(1)
        # (Line 115) }
        # (Line 116) }
    EUDEndIf()
    # (Line 118) function spawnInterior(workingSlot,buildingID,player){

@EUDFunc
def f_spawnInterior(workingSlot, buildingID_1, player):
    # (Line 119) const baseY = 3232+(768*workingSlot);
    baseY = 3232 + (768 * workingSlot)
    # (Line 120) const buildingType = buildingType[buildingID];
    buildingType_1 = buildingType[buildingID_1]
    # (Line 122) switch (buildingType) {
    EUDSwitch(buildingType_1)
    # (Line 123) case 1: // ammonation
    _t1 = EUDSwitchCase()
    # (Line 124) const units =   [206,206,205,205,206,206,205,205,  16,];//keep the door as the last unit
    if _t1(1):
        units = _ARR(FlattenList([206, 206, 205, 205, 206, 206, 205, 205, 16]))
        # (Line 125) const unitsX = [720,608,480,368,392,504,600,712,552,];
        unitsX = _ARR(FlattenList([720, 608, 480, 368, 392, 504, 600, 712, 552]))
        # (Line 126) const unitsY = [264,208,208,264,328,384,384,328,376,];
        unitsY = _ARR(FlattenList([264, 208, 208, 264, 328, 384, 384, 328, 376]))
        # (Line 128) for(var i = 0;i<units.length;i++){
        i = _TYLV([None], [0])
        if EUDWhile()(i >= units.length, neg=True):
            def _t3():
                i.__iadd__(1)
            # (Line 129) setloc(196, baseX+unitsX[i],baseY+unitsY[i]);
            f_setloc(196, baseX + unitsX[i], baseY + unitsY[i])
            # (Line 130) if(units[i]==16){
            if EUDIf()(_ARRC(units, i) == 16):
                # (Line 131) const nextUnit = CUnit.from_read(EPD(0x628438));
                nextUnit = CUnit.from_read(EPD(0x628438))
                # (Line 132) CreateUnit(1,16,196,6);//exit door
                # (Line 133) if (!Memory(0x628438, Exactly, nextUnit.ptr)) {
                DoActions(CreateUnit(1, 16, 196, 6))
                if EUDIf()(Memory(0x628438, Exactly, nextUnit.ptr), neg=True):
                    # (Line 134) GTAintro.aiLoop.add(nextUnit);
                    GTAintro.aiLoop.add(nextUnit)
                    # (Line 135) }
                    # (Line 136) } else if(units[i]!=16) {
                EUDEndIf()
            if EUDElseIf()(_ARRC(units, i) == 16, neg=True):
                # (Line 137) CreateUnit(1,units[i],196,6);
                # (Line 138) }
                DoActions(CreateUnit(1, units[i], 196, 6))
                # (Line 139) if(i==units.length-1){
            EUDEndIf()
            if EUDIf()(i == units.length - 1):
                # (Line 140) setloc(196, baseX+unitsX[units.length-1],baseY+unitsY[units.length-1]-16);
                f_setloc(196, baseX + unitsX[units.length - 1], baseY + unitsY[units.length - 1] - 16)
                # (Line 141) MoveUnit(1,GTAintro.playerUID[player],player,player+8,196);
                # (Line 142) playerCurrentBuild[player]=buildingID;
                DoActions(MoveUnit(1, GTAintro.playerUID[player], player, player + 8, 196))
                _ARRW(playerCurrentBuild, player) << (buildingID_1)
                # (Line 143) }
                # (Line 144) }
            EUDEndIf()
            # (Line 145) break;
            EUDSetContinuePoint()
            _t3()
        EUDEndWhile()
        EUDBreak()
        # (Line 147) case 2: //hospital
    _t8 = EUDSwitchCase()
    # (Line 148) break;
    if _t8(2):
        EUDBreak()
        # (Line 149) }
    # (Line 150) loadedInteriors[workingSlot]=buildingID;
    EUDEndSwitch()
    _ARRW(loadedInteriors, workingSlot) << (buildingID_1)
    # (Line 151) }
    # (Line 153) function loadInterior(buildingID,player){

@EUDFunc
def f_loadInterior(buildingID_1, player):
    # (Line 154) const workingSlot = checkInterior(buildingID);
    workingSlot = f_checkInterior(buildingID_1)
    # (Line 156) switch (buildingID) {
    EUDSwitch(buildingID_1)
    # (Line 157) case 1,3,4,5://ammonation
    _t1 = EUDSwitchCase()
    # (Line 158) if(loadedInteriors[workingSlot] == buildingID){
    if _t1(1, 3, 4, 5):
        if EUDIf()(_ARRC(loadedInteriors, workingSlot) == buildingID_1):
            # (Line 159) MoveUnit(1,GTAintro.playerUID[player],player,player+8,196);
            # (Line 160) } else {
            DoActions(MoveUnit(1, GTAintro.playerUID[player], player, player + 8, 196))
        if EUDElse()():
            # (Line 161) spawnInterior(workingSlot,buildingID,player);
            f_spawnInterior(workingSlot, buildingID_1, player)
            # (Line 162) }
            # (Line 163) break;
        EUDEndIf()
        EUDBreak()
        # (Line 165) case 2,6,7,8://hospital
    _t3 = EUDSwitchCase()
    # (Line 166) if(loadedInteriors[workingSlot] == buildingID){
    if _t3(2, 6, 7, 8):
        if EUDIf()(_ARRC(loadedInteriors, workingSlot) == buildingID_1):
            # (Line 167) MoveUnit(1,GTAintro.playerUID[player],player,player+8,196);
            # (Line 168) } else {
            DoActions(MoveUnit(1, GTAintro.playerUID[player], player, player + 8, 196))
        if EUDElse()():
            # (Line 169) const nextUnit = CUnit.from_read(EPD(0x628438));
            nextUnit = CUnit.from_read(EPD(0x628438))
            # (Line 170) CreateUnit(1,16,196,6);//exit door
            # (Line 171) if (!Memory(0x628438, Exactly, nextUnit.ptr)) {
            DoActions(CreateUnit(1, 16, 196, 6))
            if EUDIf()(Memory(0x628438, Exactly, nextUnit.ptr), neg=True):
                # (Line 172) GTAintro.aiLoop.add(nextUnit);
                GTAintro.aiLoop.add(nextUnit)
                # (Line 173) }
                # (Line 174) MoveUnit(1,GTAintro.playerUID[player],player,player+8,196);
            EUDEndIf()
            # (Line 175) loadedInteriors[workingSlot]=buildingID;
            DoActions(MoveUnit(1, GTAintro.playerUID[player], player, player + 8, 196))
            _ARRW(loadedInteriors, workingSlot) << (buildingID_1)
            # (Line 176) }
            # (Line 177) break;
        EUDEndIf()
        EUDBreak()
        # (Line 178) }
    # (Line 179) }
    EUDEndSwitch()
    # (Line 181) function leaveInterior(player){

@EUDFunc
def f_leaveInterior(player):
    # (Line 182) const inInterior = playerCurrentBuild[player];
    inInterior = playerCurrentBuild[player]
    # (Line 184) setloc(197,buildingExitX[inInterior],buildingExitY[inInterior]);
    f_setloc(197, buildingExitX[inInterior], buildingExitY[inInterior])
    # (Line 185) MoveUnit(1,GTAintro.playerUID[player],player,player+8,197);
    # (Line 186) playerCurrentBuild[player] = 0;
    DoActions(MoveUnit(1, GTAintro.playerUID[player], player, player + 8, 197))
    _ARRW(playerCurrentBuild, player) << (0)
    # (Line 187) var playersLeft = 0;
    playersLeft = _TYLV([None], [0])
    # (Line 188) for(var i = 0;i<playerCurrentBuild.length;i++){
    i = _TYLV([None], [0])
    if EUDWhile()(i >= playerCurrentBuild.length, neg=True):
        def _t2():
            i.__iadd__(1)
        # (Line 189) if(playerCurrentBuild[i]==inInterior){
        if EUDIf()(_ARRC(playerCurrentBuild, i) == inInterior):
            # (Line 190) playersLeft++;
            playersLeft.__iadd__(1)
            # (Line 191) break;
            EUDBreak()
            # (Line 192) }
            # (Line 193) }
        EUDEndIf()
        # (Line 194) if(playersLeft==0){
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    if EUDIf()(playersLeft == 0):
        # (Line 195) clearInterior(inInterior);
        f_clearInterior(inInterior)
        # (Line 196) }
        # (Line 197) }
    EUDEndIf()
