## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.core.eudfunc import EUDTraceLog, EUDTracedFunc, EUDTracedTypedFunc, EUDTracedMethod, EUDTracedTypedMethod
from eudplib.epscript.helper import _RELIMP, _TYGV, _TYSV, _TYLV, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LSH, _ALL
# (Line 16) function CountAtLoc(player: TrgPlayer, unit: TrgUnit, loc: TrgLocation) {
@EUDTypedFunc([TrgPlayer, TrgUnit, TrgLocation])
def CountAtLoc(player, unit, loc):
    # (Line 18) var x = 1700;
    x = _TYLV([None], [1700])
    # (Line 19) foreach(i : py_range(10, -1, -1)) {
    for i in range(10, -1, -1):
        # (Line 20) if (x >= py_pow(2, i)) {
        if EUDIf()(x >= pow(2, i)):
            # (Line 21) x -= py_pow(2, i);
            x.__isub__(pow(2, i))
            # (Line 22) if (!Bring(player, AtMost, x, unit, loc)) {
            if EUDIf()(Bring(player, AtMost, x, unit, loc), neg=True):
                # (Line 23) x += py_pow(2, i);
                x.__iadd__(pow(2, i))
                # (Line 24) }
                # (Line 25) }
            EUDEndIf()
            # (Line 26) }
        EUDEndIf()
        # (Line 27) return x;

    EUDReturn(x)
    # (Line 28) }
    # (Line 30) function __LocOrderBase(

# (Line 31) epd,
# (Line 32) order_lsh8,
# (Line 33) loc: TrgLocation
# (Line 34) ) {
@EUDTypedFunc([None, None, TrgLocation])
def __LocOrderBase(epd, order_lsh8, loc):
    # (Line 35) const loc_epd = loc * 5;
    loc_epd = loc * 5
    # (Line 36) DoActions(loc_epd.AddNumber(EPD(0x58DC4C)));
    DoActions(loc_epd.AddNumber(EPD(0x58DC4C)))
    # (Line 38) const x1 = dwread_epd(loc_epd);
    x1 = f_dwread_epd(loc_epd)
    # (Line 39) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 40) const y1 = dwread_epd(loc_epd);
    y1 = f_dwread_epd(loc_epd)
    # (Line 41) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 42) const x2 = dwread_epd(loc_epd);
    x2 = f_dwread_epd(loc_epd)
    # (Line 43) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 44) const y2 = dwread_epd(loc_epd);
    y2 = f_dwread_epd(loc_epd)
    # (Line 46) const x = (x1 + x2) / 2;
    x = (x1 + x2) // 2
    # (Line 47) const y = (y1 + y2) << 15;  // = (y1 + y2) / 2 * 65536
    y = _LSH((y1 + y2),15)
    # (Line 49) epd += 0x4D / 4;
    epd.__iadd__(0x4D // 4)
    # (Line 50) SetMemoryXEPD(epd, SetTo, order_lsh8, 0xFF00);
    # (Line 51) epd += (0x58 - 0x4C) / 4;
    DoActions(SetMemoryXEPD(epd, SetTo, order_lsh8, 0xFF00))
    epd.__iadd__((0x58 - 0x4C) // 4)
    # (Line 52) SetMemoryEPD(epd, SetTo, y + x);
    # (Line 53) }
    DoActions(SetMemoryEPD(epd, SetTo, y + x))
    # (Line 56) function __PosOrderBase(

# (Line 57) epd,
# (Line 58) order_lsh8,
# (Line 59) x,
# (Line 60) y
# (Line 61) ) {
@EUDFunc
def __PosOrderBase(epd, order_lsh8, x, y):
    # (Line 62) epd += 0x4D / 4;
    epd.__iadd__(0x4D // 4)
    # (Line 63) SetMemoryXEPD(epd, SetTo, order_lsh8, 0xFF00);
    # (Line 64) epd += (0x58 - 0x4C) / 4;
    DoActions(SetMemoryXEPD(epd, SetTo, order_lsh8, 0xFF00))
    epd.__iadd__((0x58 - 0x4C) // 4)
    # (Line 65) SetMemoryEPD(epd, SetTo, y * 65536 + x);
    # (Line 66) }
    DoActions(SetMemoryEPD(epd, SetTo, y * 65536 + x))
    # (Line 83) function BuildProbeEPD(epd, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildProbeEPD(epd, loc, building):
    # (Line 84) SetMemoryXEPD(epd + 0x98 / 4, SetTo, building, 0xFFFF);
    # (Line 85) __LocOrderBase(epd, 31 << 8, loc);
    DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, building, 0xFFFF))
    __LocOrderBase(epd, _LSH(31,8), loc)
    # (Line 86) }
    # (Line 103) function BuildProbe(unitPTR, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildProbe(unitPTR, loc, building):
    # (Line 104) BuildProbeEPD(EPD(unitPTR), loc, building);
    BuildProbeEPD(EPD(unitPTR), loc, building)
    # (Line 105) }
    # (Line 122) function BuildDroneEPD(epd, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildDroneEPD(epd, loc, building):
    # (Line 123) SetMemoryXEPD(epd + 0x98 / 4, SetTo, building, 0xFFFF);
    # (Line 124) __LocOrderBase(epd, 25 << 8, loc);
    DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, building, 0xFFFF))
    __LocOrderBase(epd, _LSH(25,8), loc)
    # (Line 125) }
    # (Line 142) function BuildDrone(unitPTR, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildDrone(unitPTR, loc, building):
    # (Line 143) BuildDroneEPD(EPD(unitPTR), loc, building);
    BuildDroneEPD(EPD(unitPTR), loc, building)
    # (Line 144) }
    # (Line 161) function BuildSCVEPD(epd, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildSCVEPD(epd, loc, building):
    # (Line 162) SetMemoryXEPD(epd + 0x98 / 4, SetTo, building, 0xFFFF);
    # (Line 163) __LocOrderBase(epd, 30 << 8, loc);
    DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, building, 0xFFFF))
    __LocOrderBase(epd, _LSH(30,8), loc)
    # (Line 164) }
    # (Line 181) function BuildSCV(unitPTR, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildSCV(unitPTR, loc, building):
    # (Line 182) BuildSCVEPD(EPD(unitPTR), loc, building);
    BuildSCVEPD(EPD(unitPTR), loc, building)
    # (Line 183) }
    # (Line 200) function COrderLocEPD(epd, order, loc: TrgLocation) {

@EUDTypedFunc([None, None, TrgLocation])
def COrderLocEPD(epd, order, loc):
    # (Line 201) __LocOrderBase(epd, order << 8, loc);
    __LocOrderBase(epd, _LSH(order,8), loc)
    # (Line 202) }
    # (Line 220) function COrderLoc(unitPTR, order, loc: TrgLocation) {

@EUDTypedFunc([None, None, TrgLocation])
def COrderLoc(unitPTR, order, loc):
    # (Line 221) __LocOrderBase(EPD(unitPTR), order << 8, loc);
    __LocOrderBase(EPD(unitPTR), _LSH(order,8), loc)
    # (Line 222) }
    # (Line 239) function COrderUnitEPD(unitEPD, order, targetPTR) {

@EUDFunc
def COrderUnitEPD(unitEPD, order, targetPTR):
    # (Line 240) bwrite_epd(unitEPD + 0x4D / 4,  1, order);
    f_bwrite_epd(unitEPD + 0x4D // 4, 1, order)
    # (Line 241) SetMemoryEPD(unitEPD + 0x5C / 4, SetTo, targetPTR);
    # (Line 242) }
    DoActions(SetMemoryEPD(unitEPD + 0x5C // 4, SetTo, targetPTR))
    # (Line 259) function COrderUnit(unitPTR, order, targetPTR) {

@EUDFunc
def COrderUnit(unitPTR, order, targetPTR):
    # (Line 260) COrderUnitEPD(EPD(unitPTR), order, targetPTR);
    COrderUnitEPD(EPD(unitPTR), order, targetPTR)
    # (Line 261) }
    # (Line 282) function COrderPosEPD(epd, order, x, y) {

@EUDFunc
def COrderPosEPD(epd, order, x, y):
    # (Line 283) __PosOrderBase(epd, order << 8, x, y);
    __PosOrderBase(epd, _LSH(order,8), x, y)
    # (Line 284) }
    # (Line 305) function COrderPos(unitPTR, order, x, y) {

@EUDFunc
def COrderPos(unitPTR, order, x, y):
    # (Line 306) __PosOrderBase(EPD(unitPTR), order << 8, x, y);
    __PosOrderBase(EPD(unitPTR), _LSH(order,8), x, y)
    # (Line 307) }
    # (Line 324) function RotateLocation(targetLoc: TrgLocation, originLoc: TrgLocation, angle) {

@EUDTypedFunc([TrgLocation, TrgLocation, None])
def RotateLocation(targetLoc, originLoc, angle):
    # (Line 325) const locTable = EPD(0x58DC4C);
    locTable = EPD(0x58DC4C)
    # (Line 326) const target = targetLoc * 5;
    target = targetLoc * 5
    # (Line 327) const origin = originLoc * 5;
    origin = originLoc * 5
    # (Line 328) DoActions(list(
    # (Line 329) target.AddNumber(locTable),
    # (Line 330) origin.AddNumber(locTable)
    # (Line 331) ));
    DoActions(FlattenList([target.AddNumber(locTable), origin.AddNumber(locTable)]))
    # (Line 333) const tx1 = dwread_epd(target);
    tx1 = f_dwread_epd(target)
    # (Line 334) const ox1 = dwread_epd(origin);
    ox1 = f_dwread_epd(origin)
    # (Line 335) DoActions(list(
    # (Line 336) target.AddNumber(1),
    # (Line 337) origin.AddNumber(1)
    # (Line 338) ));
    DoActions(FlattenList([target.AddNumber(1), origin.AddNumber(1)]))
    # (Line 339) const ty1 = dwread_epd(target);
    ty1 = f_dwread_epd(target)
    # (Line 340) const oy1 = dwread_epd(origin);
    oy1 = f_dwread_epd(origin)
    # (Line 341) DoActions(list(
    # (Line 342) target.AddNumber(1),
    # (Line 343) origin.AddNumber(1)
    # (Line 344) ));
    DoActions(FlattenList([target.AddNumber(1), origin.AddNumber(1)]))
    # (Line 345) const tx2 = dwread_epd(target);
    tx2 = f_dwread_epd(target)
    # (Line 346) const ox2 = dwread_epd(origin);
    ox2 = f_dwread_epd(origin)
    # (Line 347) DoActions(list(
    # (Line 348) target.AddNumber(1),
    # (Line 349) origin.AddNumber(1)
    # (Line 350) ));
    DoActions(FlattenList([target.AddNumber(1), origin.AddNumber(1)]))
    # (Line 351) const ty2 = dwread_epd(target);
    ty2 = f_dwread_epd(target)
    # (Line 352) const oy2 = dwread_epd(origin);
    oy2 = f_dwread_epd(origin)
    # (Line 354) const tx, ty = (tx1+tx2), (ty1+ty2);
    tx, ty = List2Assignable([(tx1 + tx2), (ty1 + ty2)])
    # (Line 355) const ox, oy = (ox1+ox2), (oy1+oy2);
    ox, oy = List2Assignable([(ox1 + ox2), (oy1 + oy2)])
    # (Line 356) const dx, dy = tx-ox, ty-oy;
    dx, dy = List2Assignable([tx - ox, ty - oy])
    # (Line 357) const theta = atan2(dy, dx);
    theta = f_atan2(dy, dx)
    # (Line 358) const dx2, dy2 = dx/2, dy/2;
    dx2, dy2 = List2Assignable([dx // 2, dy // 2])
    # (Line 359) const x, y = lengthdir(sqrt(dx2*dx2+dy2*dy2)+1, theta+angle);
    x, y = List2Assignable([f_lengthdir(f_sqrt(dx2 * dx2 + dy2 * dy2) + 1, theta + angle)])
    # (Line 360) const rx, ry = x-dx2, y-dy2;
    rx, ry = List2Assignable([x - dx2, y - dy2])
    # (Line 361) dwadd_epd(target, ry);
    f_dwadd_epd(target, ry)
    # (Line 362) DoActions(target.AddNumber(-1));
    DoActions(target.AddNumber(-1))
    # (Line 363) dwadd_epd(target, rx);
    f_dwadd_epd(target, rx)
    # (Line 364) DoActions(target.AddNumber(-1));
    DoActions(target.AddNumber(-1))
    # (Line 365) dwadd_epd(target, ry);
    f_dwadd_epd(target, ry)
    # (Line 366) DoActions(target.AddNumber(-1));
    DoActions(target.AddNumber(-1))
    # (Line 367) dwadd_epd(target, rx);
    f_dwadd_epd(target, rx)
    # (Line 368) }
    # (Line 382) function RemoveStatusFlagsEPD(epd, flags /*StatusFlags*/) {

@EUDFunc
def RemoveStatusFlagsEPD(epd, flags):
    # (Line 383) epd += 0xDC / 4;
    epd.__iadd__(0xDC // 4)
    # (Line 384) SetMemoryXEPD(epd, SetTo, 0, flags);
    # (Line 385) }
    DoActions(SetMemoryXEPD(epd, SetTo, 0, flags))
    # (Line 399) function RemoveStatusFlags(unitPTR, flags /*StatusFlags*/) {

@EUDFunc
def RemoveStatusFlags(unitPTR, flags):
    # (Line 400) RemoveStatusFlagsEPD(EPD(unitPTR), flags);
    RemoveStatusFlagsEPD(EPD(unitPTR), flags)
    # (Line 401) }
    # (Line 415) function SetPColor(Player: TrgPlayer, Color) {

@EUDTypedFunc([TrgPlayer, None])
def SetPColor(Player, Color):
    # (Line 416) DoActions(Player.AddNumber(0x581DD6));
    DoActions(Player.AddNumber(0x581DD6))
    # (Line 417) bwrite(Player, Color);
    f_bwrite(Player, Color)
    # (Line 421) VProc(Player, list(
    # (Line 422) Player.AddNumber(0x1FA7D16C),
    # (Line 423) Player.QueueAddTo(Player),
    # (Line 424) ));
    VProc(Player, FlattenList([Player.AddNumber(0x1FA7D16C), Player.QueueAddTo(Player)]))
    # (Line 425) bwrite_epd(Player, 2, Color);
    f_bwrite_epd(Player, 2, Color)
    # (Line 426) }
    # (Line 428) function __SpawnBase(epd, unit: TrgUnit, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit, TrgUnit])
def __SpawnBase(epd, unit, newUnit):
    # (Line 429) if (
    _t1 = EUDIf()
    # (Line 430) MemoryXEPD(epd + 0x64/4, Exactly, unit, 0xFFFF)
    # (Line 431) && MemoryXEPD(epd + 0x4E/4, Exactly, 0, 0xFF0000)
    # (Line 432) ) {
    if _t1(EUDSCAnd()(MemoryXEPD(epd + 0x64 // 4, Exactly, unit, 0xFFFF))(MemoryXEPD(epd + 0x4E // 4, Exactly, 0, 0xFF0000))()):
        # (Line 433) SetMemoryXEPD(epd + 0x4D/4, SetTo, (42 << 8) + (1 << 16), 0xFFFF00);
        # (Line 434) SetMemoryXEPD(epd + 0x98/4, SetTo, newUnit, 0xFFFF);
        DoActions(SetMemoryXEPD(epd + 0x4D // 4, SetTo, (_LSH(42,8)) + (_LSH(1,16)), 0xFFFF00))
        # (Line 435) }
        DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, newUnit, 0xFFFF))
        # (Line 436) }
    EUDEndIf()
    # (Line 450) function SpawnCocoonEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnCocoonEPD(epd, newUnit):
    # (Line 451) __SpawnBase(epd, 59, newUnit);
    __SpawnBase(epd, 59, newUnit)
    # (Line 452) }
    # (Line 466) function SpawnCocoon(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnCocoon(unitPTR, newUnit):
    # (Line 467) __SpawnBase(EPD(unitPTR), 59, newUnit);
    __SpawnBase(EPD(unitPTR), 59, newUnit)
    # (Line 468) }
    # (Line 482) function SpawnEggEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnEggEPD(epd, newUnit):
    # (Line 483) __SpawnBase(epd, 36, newUnit);
    __SpawnBase(epd, 36, newUnit)
    # (Line 484) }
    # (Line 498) function SpawnEgg(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnEgg(unitPTR, newUnit):
    # (Line 499) __SpawnBase(EPD(unitPTR), 36, newUnit);
    __SpawnBase(EPD(unitPTR), 36, newUnit)
    # (Line 500) }
    # (Line 514) function MorphLarvaEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def MorphLarvaEPD(epd, newUnit):
    # (Line 515) if (MemoryXEPD(epd + 0x64/4, Exactly, 35, 0xFFFF)) {
    if EUDIf()(MemoryXEPD(epd + 0x64 // 4, Exactly, 35, 0xFFFF)):
        # (Line 516) SetMemoryXEPD(epd + 0x4D/4, SetTo, 42 << 8, 0xFFFF00);
        # (Line 517) SetMemoryXEPD(epd + 0x98/4, SetTo, newUnit, 0xFFFF);
        DoActions(SetMemoryXEPD(epd + 0x4D // 4, SetTo, _LSH(42,8), 0xFFFF00))
        # (Line 518) }
        DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, newUnit, 0xFFFF))
        # (Line 519) }
    EUDEndIf()
    # (Line 533) function MorphLarva(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def MorphLarva(unitPTR, newUnit):
    # (Line 534) MorphLarvaEPD(EPD(unitPTR), newUnit);
    MorphLarvaEPD(EPD(unitPTR), newUnit)
    # (Line 535) }
    # (Line 549) function TrainUnitEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def TrainUnitEPD(epd, newUnit):
    # (Line 550) const nU_and_lsh16 = newUnit * 65537;
    nU_and_lsh16 = newUnit * 65537
    # (Line 551) VProc(epd, list(
    # (Line 552) epd.AddNumber(0x98/4),
    # (Line 553) epd.SetDest(EPD(0x6509B0)),
    # (Line 554) ));
    VProc(epd, FlattenList([epd.AddNumber(0x98 // 4), epd.SetDest(EPD(0x6509B0))]))
    # (Line 555) DoActions(list(
    # (Line 556) SetDeaths(CurrentPlayer, SetTo, nU_and_lsh16, 0),
    # (Line 557) SetMemory(0x6509B0, Add, 1),
    # (Line 558) SetDeaths(CurrentPlayer, SetTo, nU_and_lsh16, 0),
    # (Line 559) SetMemory(0x6509B0, Add, 1),
    # (Line 560) SetDeathsX(CurrentPlayer, SetTo, newUnit, 0, 0xFFFF),
    # (Line 561) SetMemory(0x6509B0, Add, 1),
    # (Line 562) SetDeathsX(CurrentPlayer, SetTo, 38 << 16, 0, 0xFF0000),
    # (Line 563) ));
    DoActions(FlattenList([SetDeaths(CurrentPlayer, SetTo, nU_and_lsh16, 0), SetMemory(0x6509B0, Add, 1), SetDeaths(CurrentPlayer, SetTo, nU_and_lsh16, 0), SetMemory(0x6509B0, Add, 1), SetDeathsX(CurrentPlayer, SetTo, newUnit, 0, 0xFFFF), SetMemory(0x6509B0, Add, 1), SetDeathsX(CurrentPlayer, SetTo, _LSH(38,16), 0, 0xFF0000)]))
    # (Line 564) setcurpl2cpcache();
    f_setcurpl2cpcache()
    # (Line 565) }
    # (Line 579) function TrainUnit(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def TrainUnit(unitPTR, newUnit):
    # (Line 580) TrainUnitEPD(EPD(unitPTR), newUnit);
    TrainUnitEPD(EPD(unitPTR), newUnit)
    # (Line 581) }
    # (Line 595) function SetUnitColorEPD(epd, color) {

@EUDFunc
def SetUnitColorEPD(epd, color):
    # (Line 596) epd += 0x0C/4;
    epd.__iadd__(0x0C // 4)
    # (Line 597) const sprite = epdread_epd(epd);
    sprite = f_epdread_epd(epd)
    # (Line 598) DoActions(sprite.AddNumber(0x0A/4));
    DoActions(sprite.AddNumber(0x0A // 4))
    # (Line 599) SetMemoryXEPD(sprite, SetTo, color * 65536, 0xFF0000);
    # (Line 600) }
    DoActions(SetMemoryXEPD(sprite, SetTo, color * 65536, 0xFF0000))
    # (Line 614) function SetUnitColor(unitPTR, color) {

@EUDFunc
def SetUnitColor(unitPTR, color):
    # (Line 615) SetUnitColorEPD(EPD(unitPTR), color);
    SetUnitColorEPD(EPD(unitPTR), color)
    # (Line 616) }
    # (Line 636) function SetLocationToUnitEPD(location: TrgLocation, unitEPD, CUnitOffsetX, CUnitOffsetY) {

@EUDTypedFunc([TrgLocation, None, None, None])
def SetLocationToUnitEPD(location, unitEPD, CUnitOffsetX, CUnitOffsetY):
    # (Line 637) if (CUnitOffsetX == CUnitOffsetY) {
    if EUDIf()(CUnitOffsetX == CUnitOffsetY):
        # (Line 638) unitEPD += CUnitOffsetX/4;
        unitEPD.__iadd__(CUnitOffsetX // 4)
        # (Line 639) setloc_epd(location, unitEPD);
        f_setloc_epd(location, unitEPD)
        # (Line 640) } else {
    if EUDElse()():
        # (Line 641) const x = wread_epd(unitEPD + CUnitOffsetX/4, 0);
        x = f_wread_epd(unitEPD + CUnitOffsetX // 4, 0)
        # (Line 642) const y = wread_epd(unitEPD + CUnitOffsetY/4, 2);
        y = f_wread_epd(unitEPD + CUnitOffsetY // 4, 2)
        # (Line 643) setloc(location, x, y);
        f_setloc(location, x, y)
        # (Line 644) }
        # (Line 645) }
    EUDEndIf()
    # (Line 665) function SetLocationToUnit(location: TrgLocation, unitPTR, CUnitOffsetX, CUnitOffsetY) {

@EUDTypedFunc([TrgLocation, None, None, None])
def SetLocationToUnit(location, unitPTR, CUnitOffsetX, CUnitOffsetY):
    # (Line 666) SetLocationToUnitEPD(location, EPD(unitPTR), CUnitOffsetX, CUnitOffsetY);
    SetLocationToUnitEPD(location, EPD(unitPTR), CUnitOffsetX, CUnitOffsetY)
    # (Line 667) }
    # (Line 690) function SetLocation(location: TrgLocation, X, Y, width, height) {

@EUDTypedFunc([TrgLocation, None, None, None, None])
def SetLocation(location, X, Y, width, height):
    # (Line 691) setloc(location, X, Y);
    f_setloc(location, X, Y)
    # (Line 692) dilateloc(location, width/2, height/2);
    f_dilateloc(location, width // 2, height // 2)
    # (Line 693) }
    # (Line 710) function EUDMoveLocation(Location: TrgLocation, X, Y) {

@EUDTypedFunc([TrgLocation, None, None])
def EUDMoveLocation(Location, X, Y):
    # (Line 711) addloc(Location, X, Y);
    f_addloc(Location, X, Y)
    # (Line 712) }
    # (Line 716) function ScreenShake(x, y, tempLoc: TrgLocation) {

@EUDTypedFunc([None, None, TrgLocation])
def ScreenShake(x, y, tempLoc):
    # (Line 718) const randX, randY = rand(), rand();
    randX, randY = List2Assignable([f_rand(), f_rand()])
    # (Line 719) if (IsUserCP()) {
    if EUDIf()(IsUserCP()):
        # (Line 720) const SCREEN_X, SCREEN_Y = 0x628448, 0x628470;
        SCREEN_X, SCREEN_Y = List2Assignable([0x628448, 0x628470])
        # (Line 721) const rX, rY = (randX % x) - x/2, (randY % y) - y/2;
        rX, rY = List2Assignable([(randX % x) - x // 2, (randY % y) - y // 2])
        # (Line 722) const screenX = dwread(SCREEN_X);
        screenX = f_dwread(SCREEN_X)
        # (Line 723) const screenY = dwread(SCREEN_Y);
        screenY = f_dwread(SCREEN_Y)
        # (Line 724) VProc(list(rX, rY), list(
        # (Line 725) rX.QueueAddTo(screenX),
        # (Line 726) rY.QueueAddTo(screenY)
        # (Line 727) ));
        VProc(FlattenList([rX, rY]), FlattenList([rX.QueueAddTo(screenX), rY.QueueAddTo(screenY)]))
        # (Line 728) setloc(tempLoc, screenX, screenY);
        f_setloc(tempLoc, screenX, screenY)
        # (Line 729) CenterView(64);
        # (Line 730) const chkt = GetChkTokenized();
        DoActions(CenterView(64))
        chkt = GetChkTokenized()
        # (Line 731) const dim = chkt.getsection("DIM");
        dim = chkt.getsection("DIM")
        # (Line 732) const mapX, mapY = b2i2(dim) * 16, b2i2(dim, 2) * 16;  // ร 32 รท 2 (map center)
        mapX, mapY = List2Assignable([b2i2(dim) * 16, b2i2(dim, 2) * 16])
        # (Line 733) addloc(tempLoc, mapX - dwread(SCREEN_X), mapY - dwread(SCREEN_Y));
        f_addloc(tempLoc, mapX - f_dwread(SCREEN_X), mapY - f_dwread(SCREEN_Y))
        # (Line 734) CenterView(tempLoc);
        # (Line 735) }
        DoActions(CenterView(tempLoc))
        # (Line 736) }
    EUDEndIf()
    # (Line 756) function hotkeyUnitEPD(epd, player: TrgPlayer, hotkey, slot) {

@EUDTypedFunc([None, TrgPlayer, None, None])
def f_hotkeyUnitEPD(epd, player, hotkey, slot):
    # (Line 757) epd += 0xA5 / 4;
    epd.__iadd__(0xA5 // 4)
    # (Line 758) const tosread_epd = readgen_epd(0xFF00, list(0, py_eval('lambda x: 8*x')));
    tosread_epd = f_readgen_epd(0xFF00, FlattenList([0, eval('lambda x: 8*x')]))
    # (Line 759) const alphaID = tosread_epd(epd);
    alphaID = tosread_epd(epd)
    # (Line 760) if (epd == 19025 + 0xA5/4) {
    if EUDIf()(epd == 19025 + 0xA5 // 4):
        # (Line 761) DoActions(alphaID.AddNumber(1));
        DoActions(alphaID.AddNumber(1))
        # (Line 762) } else {
    if EUDElse()():
        # (Line 763) const diff = 1701 - (161866 - epd) / 84;
        diff = 1701 - (161866 - epd) // 84
        # (Line 764) VProc(diff, diff.QueueAddTo(alphaID));
        VProc(diff, diff.QueueAddTo(alphaID))
        # (Line 765) }
        # (Line 766) SetDeaths(EPD(0x57FE60) + 216 * player + slot, SetTo, alphaID, hotkey);
    EUDEndIf()
    # (Line 767) }
    DoActions(SetDeaths(EPD(0x57FE60) + 216 * player + slot, SetTo, alphaID, hotkey))
    # (Line 787) function hotkeyUnit(unitPTR, player: TrgPlayer, hotkey, slot) {

@EUDTypedFunc([None, TrgPlayer, None, None])
def f_hotkeyUnit(unitPTR, player, hotkey, slot):
    # (Line 788) hotkeyUnitEPD(EPD(unitPTR), player, hotkey, slot);
    f_hotkeyUnitEPD(EPD(unitPTR), player, hotkey, slot)
    # (Line 789) }
    # (Line 791) function __GetLocCoord(loc: TrgLocation) {

@EUDTypedFunc([TrgLocation])
def __GetLocCoord(loc):
    # (Line 792) const loc_epd = loc * 5;
    loc_epd = loc * 5
    # (Line 793) DoActions(loc_epd.AddNumber(EPD(0x58DC4C)));
    DoActions(loc_epd.AddNumber(EPD(0x58DC4C)))
    # (Line 794) const x1 = dwread_epd(loc_epd);
    x1 = f_dwread_epd(loc_epd)
    # (Line 795) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 796) const y1 = dwread_epd(loc_epd);
    y1 = f_dwread_epd(loc_epd)
    # (Line 797) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 798) const x2 = dwread_epd(loc_epd);
    x2 = f_dwread_epd(loc_epd)
    # (Line 799) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 800) const y2 = dwread_epd(loc_epd);
    y2 = f_dwread_epd(loc_epd)
    # (Line 801) return x1, y1, x2, y2;
    EUDReturn(x1, y1, x2, y2)
    # (Line 802) }
    # (Line 816) function LocationAngle(originLoc: TrgLocation, destLoc: TrgLocation) {

@EUDTypedFunc([TrgLocation, TrgLocation])
def LocationAngle(originLoc, destLoc):
    # (Line 817) const ox1, oy1, ox2, oy2 = __GetLocCoord(originLoc);
    ox1, oy1, ox2, oy2 = List2Assignable([__GetLocCoord(originLoc)])
    # (Line 818) const dx1, dy1, dx2, dy2 = __GetLocCoord(destLoc);
    dx1, dy1, dx2, dy2 = List2Assignable([__GetLocCoord(destLoc)])
    # (Line 819) const x1 = ox1 + ox2;
    x1 = ox1 + ox2
    # (Line 820) const y1 = oy1 + oy2;
    y1 = oy1 + oy2
    # (Line 821) const x2 = dx1 + dx2;
    x2 = dx1 + dx2
    # (Line 822) const y2 = dy1 + dy2;
    y2 = dy1 + dy2
    # (Line 823) return atan2(x2 - x1, y1 - y2);
    EUDReturn(f_atan2(x2 - x1, y1 - y2))
    # (Line 824) }
    # (Line 827) function GetAngle(originLoc: TrgLocation, destLoc: TrgLocation) {

@EUDTypedFunc([TrgLocation, TrgLocation])
def GetAngle(originLoc, destLoc):
    # (Line 828) return LocationAngle(originLoc, destLoc);
    EUDReturn(LocationAngle(originLoc, destLoc))
    # (Line 829) }
    # (Line 843) function LocationDistance(loc1: TrgLocation, loc2: TrgLocation) {

@EUDTypedFunc([TrgLocation, TrgLocation])
def LocationDistance(loc1, loc2):
    # (Line 844) const ox1, oy1, ox2, oy2 = __GetLocCoord(loc1);
    ox1, oy1, ox2, oy2 = List2Assignable([__GetLocCoord(loc1)])
    # (Line 845) const dx1, dy1, dx2, dy2 = __GetLocCoord(loc2);
    dx1, dy1, dx2, dy2 = List2Assignable([__GetLocCoord(loc2)])
    # (Line 846) const x = dx1 + dx2 - (ox1 + ox2);
    x = dx1 + dx2 - (ox1 + ox2)
    # (Line 847) const y = dy1 + dy2 - (oy1 + oy2);
    y = dy1 + dy2 - (oy1 + oy2)
    # (Line 848) return sqrt(x*x + y*y) / 2;
    EUDReturn(f_sqrt(x * x + y * y) // 2)
    # (Line 849) }
    # (Line 852) function LocationDistanceVal(variable, loc1: TrgLocation, loc2: TrgLocation) {

@EUDTypedFunc([None, TrgLocation, TrgLocation])
def LocationDistanceVal(variable, loc1, loc2):
    # (Line 853) return LocationDistance(loc1, loc2);
    EUDReturn(LocationDistance(loc1, loc2))
    # (Line 854) }
    # (Line 875) function Distance(x1, y1, x2, y2) {

@EUDFunc
def Distance(x1, y1, x2, y2):
    # (Line 876) const x = x2 - x1;
    x = x2 - x1
    # (Line 877) const y = y2 - y1;
    y = y2 - y1
    # (Line 878) return sqrt(x*x + y*y);
    EUDReturn(f_sqrt(x * x + y * y))
    # (Line 879) }
    # (Line 898) function PolarLocation(loc: TrgLocation, length, angle) {

@EUDTypedFunc([TrgLocation, None, None])
def PolarLocation(loc, length, angle):
    # (Line 899) const x, y = lengthdir(length, angle);
    x, y = List2Assignable([f_lengthdir(length, angle)])
    # (Line 900) addloc(loc, x, y);
    f_addloc(loc, x, y)
    # (Line 901) }
    # (Line 924) function CheckNoneTargetSkillEPD(

# (Line 925) unitEPD,
# (Line 926) range,
# (Line 927) unitLoc: TrgLocation,
# (Line 928) targetLoc: TrgLocation,
# (Line 929) skillOrder /*Order*/
# (Line 930) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckNoneTargetSkillEPD(unitEPD, range, unitLoc, targetLoc, skillOrder):
    # (Line 931) unitEPD += 0x4D/4;
    unitEPD.__iadd__(0x4D // 4)
    # (Line 932) if (MemoryXEPD(unitEPD, Exactly, skillOrder * 256, 0xFF00)) {
    if EUDIf()(MemoryXEPD(unitEPD, Exactly, skillOrder * 256, 0xFF00)):
        # (Line 933) unitEPD += -((0x4D - 0x28)/4);
        unitEPD.__iadd__(-((0x4D - 0x28) // 4))
        # (Line 934) const x, y = posread_epd(unitEPD);
        x, y = List2Assignable([f_posread_epd(unitEPD)])
        # (Line 935) setloc(unitLoc, x, y);
        f_setloc(unitLoc, x, y)
        # (Line 936) unitEPD += (0x58 - 0x28)/4;
        unitEPD.__iadd__((0x58 - 0x28) // 4)
        # (Line 937) setloc_epd(targetLoc, unitEPD);
        f_setloc_epd(targetLoc, unitEPD)
        # (Line 939) if (range > LocationDistance(unitLoc, targetLoc)) {
        if EUDIf()(range <= LocationDistance(unitLoc, targetLoc), neg=True):
            # (Line 940) MoveLocation(targetLoc, 227, AllPlayers, targetLoc);
            # (Line 941) unitEPD += -((0x58 - 0x4C)/4);
            DoActions(MoveLocation(targetLoc, 227, AllPlayers, targetLoc))
            unitEPD.__iadd__(-((0x58 - 0x4C) // 4))
            # (Line 942) SetMemoryXEPD(unitEPD, SetTo, 0x100, 0xFF00);
            # (Line 943) unitEPD += -((0x4D - 0x10)/4);
            DoActions(SetMemoryXEPD(unitEPD, SetTo, 0x100, 0xFF00))
            unitEPD.__iadd__(-((0x4D - 0x10) // 4))
            # (Line 944) SetMemoryEPD(unitEPD, SetTo, x + y * 65536);
            # (Line 945) return True;
            DoActions(SetMemoryEPD(unitEPD, SetTo, x + y * 65536))
            EUDReturn(True)
            # (Line 946) }
            # (Line 947) }
        EUDEndIf()
        # (Line 948) return False;
    EUDEndIf()
    EUDReturn(False)
    # (Line 949) }
    # (Line 972) function CheckNoneTargetSkill(

# (Line 973) unitPTR,
# (Line 974) range,
# (Line 975) unitLoc: TrgLocation,
# (Line 976) targetLoc: TrgLocation,
# (Line 977) skillOrder /*Order*/
# (Line 978) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckNoneTargetSkill(unitPTR, range, unitLoc, targetLoc, skillOrder):
    # (Line 979) return CheckNoneTargetSkillEPD(
    # (Line 980) EPD(unitPTR),
    # (Line 981) range,
    # (Line 982) unitLoc,
    # (Line 983) targetLoc,
    # (Line 984) skillOrder /*Order*/
    # (Line 985) );
    EUDReturn(CheckNoneTargetSkillEPD(EPD(unitPTR), range, unitLoc, targetLoc, skillOrder))
    # (Line 986) }
    # (Line 1005) function SetLocationToUnitSafeEPD(location: TrgLocation, unitEPD, posX) {

@EUDTypedFunc([TrgLocation, None, None])
def SetLocationToUnitSafeEPD(location, unitEPD, posX):
    # (Line 1006) unitEPD += posX/4;
    unitEPD.__iadd__(posX // 4)
    # (Line 1007) setloc_epd(location, unitEPD);
    f_setloc_epd(location, unitEPD)
    # (Line 1008) }
    # (Line 1026) function SetLocationToUnitSafe(location: TrgLocation, unitPTR, posX) {

@EUDTypedFunc([TrgLocation, None, None])
def SetLocationToUnitSafe(location, unitPTR, posX):
    # (Line 1027) SetLocationToUnitSafeEPD(location, EPD(unitPTR), posX);
    SetLocationToUnitSafeEPD(location, EPD(unitPTR), posX)
    # (Line 1028) }
    # (Line 1051) function CheckTargetSkillEPD(

# (Line 1052) unitEPD,
# (Line 1053) range,
# (Line 1054) unitLoc: TrgLocation,
# (Line 1055) targetLoc: TrgLocation,
# (Line 1056) skillOrder
# (Line 1057) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckTargetSkillEPD(unitEPD, range, unitLoc, targetLoc, skillOrder):
    # (Line 1058) unitEPD += 19;  // 0x4D orderID
    unitEPD.__iadd__(19)
    # (Line 1059) if (MemoryXEPD(unitEPD, Exactly, skillOrder * 256, 0xFF00)) {
    if EUDIf()(MemoryXEPD(unitEPD, Exactly, skillOrder * 256, 0xFF00)):
        # (Line 1060) unitEPD += 4;  // 0x5C orderTargetUnit
        unitEPD.__iadd__(4)
        # (Line 1061) if (MemoryEPD(unitEPD, Exactly, 0)) return False;
        if EUDIf()(MemoryEPD(unitEPD, Exactly, 0)):
            EUDReturn(False)
            # (Line 1062) unitEPD -= 1;  // 0x58 orderTargetPos
        EUDEndIf()
        unitEPD.__isub__(1)
        # (Line 1063) const tx, ty = posread_epd(unitEPD);
        tx, ty = List2Assignable([f_posread_epd(unitEPD)])
        # (Line 1064) unitEPD -= 12;  // 0x28 position
        unitEPD.__isub__(12)
        # (Line 1065) const x, y = posread_epd(unitEPD);
        x, y = List2Assignable([f_posread_epd(unitEPD)])
        # (Line 1066) const dx, dy = tx - x, ty - y;
        dx, dy = List2Assignable([tx - x, ty - y])
        # (Line 1067) if (dx*dx + dy*dy < range*range) {
        if EUDIf()(dx * dx + dy * dy >= range * range, neg=True):
            # (Line 1068) setloc(unitLoc, x, y);
            f_setloc(unitLoc, x, y)
            # (Line 1069) setloc(targetLoc, tx, ty);
            f_setloc(targetLoc, tx, ty)
            # (Line 1070) DoActions(list(
            # (Line 1071) unitEPD.SubtractNumber(6),  // 0x10 moveTarget
            # (Line 1072) RemoveUnitAt(1, 101, 255, P9),
            # (Line 1073) ));
            DoActions(FlattenList([unitEPD.SubtractNumber(6), RemoveUnitAt(1, 101, 255, P9)]))
            # (Line 1074) SetMemoryEPD(unitEPD, SetTo, x + y * 65536);
            # (Line 1076) unitEPD += 15;  // 0x4D orderID
            DoActions(SetMemoryEPD(unitEPD, SetTo, x + y * 65536))
            unitEPD.__iadd__(15)
            # (Line 1077) SetMemoryXEPD(unitEPD, SetTo, 0x100, 0xFF00);
            # (Line 1078) return True;
            DoActions(SetMemoryXEPD(unitEPD, SetTo, 0x100, 0xFF00))
            EUDReturn(True)
            # (Line 1079) }
            # (Line 1080) }
        EUDEndIf()
        # (Line 1081) return False;
    EUDEndIf()
    EUDReturn(False)
    # (Line 1082) }
    # (Line 1105) function CheckTargetSkill(

# (Line 1106) unitPTR,
# (Line 1107) range,
# (Line 1108) unitLoc: TrgLocation,
# (Line 1109) targetLoc: TrgLocation,
# (Line 1110) skillOrder
# (Line 1111) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckTargetSkill(unitPTR, range, unitLoc, targetLoc, skillOrder):
    # (Line 1112) return CheckTargetSkillEPD(EPD(unitPTR), range, unitLoc, targetLoc, skillOrder);
    EUDReturn(CheckTargetSkillEPD(EPD(unitPTR), range, unitLoc, targetLoc, skillOrder))
    # (Line 1113) }
    # (Line 1130) function CBringEPD(unitEPD, location: TrgLocation, dummyUnit: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def CBringEPD(unitEPD, location, dummyUnit):
    # (Line 1131) MoveLocation(location, dummyUnit, AllPlayers, location);
    # (Line 1132) const unitType = unitEPD + 0x64/4;
    DoActions(MoveLocation(location, dummyUnit, AllPlayers, location))
    unitType = unitEPD + 0x64 // 4
    # (Line 1133) const originalUnitType = wread_epd(unitType, 0);
    originalUnitType = f_wread_epd(unitType, 0)
    # (Line 1134) SetMemoryXEPD(unitType, SetTo, dummyUnit, 0xFFFF);
    # (Line 1135) const ret = l2v(Bring(AllPlayers, AtLeast, 1, dummyUnit, location));
    DoActions(SetMemoryXEPD(unitType, SetTo, dummyUnit, 0xFFFF))
    ret = _L2V(Bring(AllPlayers, AtLeast, 1, dummyUnit, location))
    # (Line 1136) SetMemoryXEPD(unitType, SetTo, originalUnitType, 0xFFFF);
    # (Line 1137) return ret;
    DoActions(SetMemoryXEPD(unitType, SetTo, originalUnitType, 0xFFFF))
    EUDReturn(ret)
    # (Line 1138) }
    # (Line 1155) function CBring(unitPTR, location: TrgLocation, dummyUnit: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def CBring(unitPTR, location, dummyUnit):
    # (Line 1156) return CBringEPD(EPD(unitPTR), location, dummyUnit);
    EUDReturn(CBringEPD(EPD(unitPTR), location, dummyUnit))
    # (Line 1157) }
    # (Line 1168) function BuildResetEPD(unitEPD) {

@EUDFunc
def BuildResetEPD(unitEPD):
    # (Line 1169) VProc(unitEPD, list(
    # (Line 1170) unitEPD.AddNumber(0x98/4),
    # (Line 1171) unitEPD.SetDest(EPD(0x6509B0)),
    # (Line 1172) ));
    VProc(unitEPD, FlattenList([unitEPD.AddNumber(0x98 // 4), unitEPD.SetDest(EPD(0x6509B0))]))
    # (Line 1173) setcurpl2cpcache(actions=list(
    # (Line 1174) SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0),
    # (Line 1175) SetMemory(0x6509B0, Add, 1),
    # (Line 1176) SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0),
    # (Line 1177) SetMemory(0x6509B0, Add, 1),
    # (Line 1178) SetDeathsX(CurrentPlayer, SetTo, 228, 0, 0xFFFF),
    # (Line 1179) SetMemory(0x6509B0, Add, 1),
    # (Line 1180) SetDeathsX(CurrentPlayer, SetTo, 2 << 16, 0, 0xFFFF0000),
    # (Line 1181) ));
    f_setcurpl2cpcache(actions=FlattenList([SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0), SetMemory(0x6509B0, Add, 1), SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0), SetMemory(0x6509B0, Add, 1), SetDeathsX(CurrentPlayer, SetTo, 228, 0, 0xFFFF), SetMemory(0x6509B0, Add, 1), SetDeathsX(CurrentPlayer, SetTo, _LSH(2,16), 0, 0xFFFF0000)]))
    # (Line 1182) }
    # (Line 1193) function BuildReset(unitPTR) {

@EUDFunc
def BuildReset(unitPTR):
    # (Line 1194) BuildResetEPD(EPD(unitPTR));
    BuildResetEPD(EPD(unitPTR))
    # (Line 1195) }
    # (Line 1209) function BuildCheckEPD(unitEPD, unit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def BuildCheckEPD(unitEPD, unit):
    # (Line 1210) unitEPD += 0x98 / 4;  // buildQueue
    unitEPD.__iadd__(0x98 // 4)
    # (Line 1211) if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
    if EUDIf()(MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)):
        # (Line 1212) return True;
        EUDReturn(True)
        # (Line 1213) } else {
    if EUDElse()():
        # (Line 1214) const mulUnit = unit * 65536;
        mulUnit = unit * 65536
        # (Line 1215) if (MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)) {
        if EUDIf()(MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)):
            # (Line 1216) return True;
            EUDReturn(True)
            # (Line 1217) } else {
        if EUDElse()():
            # (Line 1218) unitEPD += 1;
            unitEPD.__iadd__(1)
            # (Line 1219) if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
            if EUDIf()(MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)):
                # (Line 1220) return True;
                EUDReturn(True)
                # (Line 1221) } else if (MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)) {
            if EUDElseIf()(MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)):
                # (Line 1222) return True;
                EUDReturn(True)
                # (Line 1223) } else {
            if EUDElse()():
                # (Line 1224) unitEPD += 1;
                unitEPD.__iadd__(1)
                # (Line 1225) if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
                if EUDIf()(MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)):
                    # (Line 1226) return True;
                    EUDReturn(True)
                    # (Line 1227) }
                    # (Line 1228) }
                EUDEndIf()
                # (Line 1229) }
            EUDEndIf()
            # (Line 1230) }
        EUDEndIf()
        # (Line 1231) return False;
    EUDEndIf()
    EUDReturn(False)
    # (Line 1232) }
    # (Line 1246) function BuildCheck(unitPTR, unit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def BuildCheck(unitPTR, unit):
    # (Line 1247) return BuildCheckEPD(EPD(unitPTR), unit);
    EUDReturn(BuildCheckEPD(EPD(unitPTR), unit))
    # (Line 1248) }
    # (Line 1271) function AttackGround(

# (Line 1272) attackLoc: TrgLocation,
# (Line 1273) targetLoc: TrgLocation,
# (Line 1274) attackUnit: TrgUnit,
# (Line 1275) targetUnit: TrgUnit,
# (Line 1276) player: TrgPlayer
# (Line 1277) ) {
@EUDTypedFunc([TrgLocation, TrgLocation, TrgUnit, TrgUnit, TrgPlayer])
def AttackGround(attackLoc, targetLoc, attackUnit, targetUnit, player):
    # (Line 1278) if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    if EUDIf()(Memory(0x628438, Exactly, 0)):
        EUDReturn()
        # (Line 1279) const aUnit = cunitepdread_epd(EPD(0x628438))[[1]];
    EUDEndIf()
    aUnit = f_cunitepdread_epd(EPD(0x628438))[1]
    # (Line 1280) CreateUnit(1, attackUnit, attackLoc, player);
    # (Line 1281) DoActions(aUnit.AddNumber(0x110 / 4));
    DoActions(CreateUnit(1, attackUnit, attackLoc, player))
    DoActions(aUnit.AddNumber(0x110 // 4))
    # (Line 1282) SetMemoryEPD(aUnit, Add, 2);  // aUnit + 0x110 (CUnit::removeTimer)
    # (Line 1284) if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    DoActions(SetMemoryEPD(aUnit, Add, 2))
    if EUDIf()(Memory(0x628438, Exactly, 0)):
        EUDReturn()
        # (Line 1285) const tunitptr, tunit = cunitepdread_epd(EPD(0x628438));
    EUDEndIf()
    tunitptr, tunit = List2Assignable([f_cunitepdread_epd(EPD(0x628438))])
    # (Line 1286) CreateUnit(1, targetUnit, targetLoc, player);
    # (Line 1287) DoActions(list(
    DoActions(CreateUnit(1, targetUnit, targetLoc, player))
    # (Line 1288) tunit.AddNumber(0x110 / 4),
    # (Line 1289) aUnit.AddNumber(-((0x110 - 0x5C) / 4))
    # (Line 1290) ));
    DoActions(FlattenList([tunit.AddNumber(0x110 // 4), aUnit.AddNumber(-((0x110 - 0x5C) // 4))]))
    # (Line 1291) SetMemoryEPD(aUnit, SetTo, tunitptr);  // aUnit + 0x5C (CUnit::targetUnit)
    # (Line 1292) SetMemoryEPD(tunit, Add, 2);  // tunit + 0x110 (CUnit::removeTimer)
    DoActions(SetMemoryEPD(aUnit, SetTo, tunitptr))
    # (Line 1294) DoActions(aUnit.AddNumber(-((0x5C - 0x4C) / 4)));
    DoActions(SetMemoryEPD(tunit, Add, 2))
    DoActions(aUnit.AddNumber(-((0x5C - 0x4C) // 4)))
    # (Line 1295) SetMemoryXEPD(aUnit, SetTo, 0xA00, 0xFF00);  // order[10]=attack, 0x4D (CUnit::order)
    # (Line 1296) }
    DoActions(SetMemoryXEPD(aUnit, SetTo, 0xA00, 0xFF00))
    # (Line 1310) function AddStatusFlagsEPD(epd, flags /*StatusFlags*/) {

@EUDFunc
def AddStatusFlagsEPD(epd, flags):
    # (Line 1311) epd += 0xDC / 4;
    epd.__iadd__(0xDC // 4)
    # (Line 1312) SetMemoryXEPD(epd, SetTo, ~0, flags);
    # (Line 1313) }
    DoActions(SetMemoryXEPD(epd, SetTo, ~0, flags))
    # (Line 1327) function AddStatusFlags(unitPTR, flags /*StatusFlags*/) {

@EUDFunc
def AddStatusFlags(unitPTR, flags):
    # (Line 1328) unitPTR += 0xDC;
    unitPTR.__iadd__(0xDC)
    # (Line 1329) SetMemoryX(unitPTR, SetTo, ~0, flags);
    # (Line 1330) }
    DoActions(SetMemoryX(unitPTR, SetTo, ~0, flags))
    # (Line 1347) function AddSizeLocation(location: TrgLocation, width, height) {

@EUDTypedFunc([TrgLocation, None, None])
def AddSizeLocation(location, width, height):
    # (Line 1348) dilateloc(location, width, height);
    f_dilateloc(location, width, height)
    # (Line 1349) }
    # (Line 1363) function CGive(ptr ,NewOwner: TrgPlayer) {

@EUDTypedFunc([None, TrgPlayer])
def CGive(ptr, NewOwner):
    # (Line 1364) const epd = EPD(ptr);
    epd = EPD(ptr)
    # (Line 1365) const player = epd + 0x4C / 4;
    player = epd + 0x4C // 4
    # (Line 1366) const Owner = bread_epd(player, 0);
    Owner = f_bread_epd(player, 0)
    # (Line 1367) SetMemoryXEPD(player, SetTo, NewOwner, 0xFF);
    # (Line 1368) const prv, nxt = epd + 0x68 / 4, epd + 0x6C / 4;
    DoActions(SetMemoryXEPD(player, SetTo, NewOwner, 0xFF))
    prv, nxt = List2Assignable([epd + 0x68 // 4, epd + 0x6C // 4])
    # (Line 1369) const prev_ptr, prev_epd = cunitepdread_epd(prv);
    prev_ptr, prev_epd = List2Assignable([f_cunitepdread_epd(prv)])
    # (Line 1370) const next_ptr, next_epd = cunitepdread_epd(nxt);
    next_ptr, next_epd = List2Assignable([f_cunitepdread_epd(nxt)])
    # (Line 1371) if(prev_ptr >= 0x59CCA8) {
    if EUDIf()(prev_ptr >= 0x59CCA8):
        # (Line 1372) dwwrite_epd(prev_epd + 0x6C / 4, next_ptr);
        f_dwwrite_epd(prev_epd + 0x6C // 4, next_ptr)
        # (Line 1373) } else {
    if EUDElse()():
        # (Line 1374) dwwrite_epd(EPD(0x6283F8) + Owner, next_ptr);
        f_dwwrite_epd(EPD(0x6283F8) + Owner, next_ptr)
        # (Line 1375) }
        # (Line 1376) if(next_ptr >= 0x59CCA8) {
    EUDEndIf()
    if EUDIf()(next_ptr >= 0x59CCA8):
        # (Line 1377) dwwrite_epd(next_epd + 0x68 / 4, prev_ptr);
        f_dwwrite_epd(next_epd + 0x68 // 4, prev_ptr)
        # (Line 1378) }
        # (Line 1379) const NewHeader = EPD(0x6283F8) + NewOwner;
    EUDEndIf()
    NewHeader = EPD(0x6283F8) + NewOwner
    # (Line 1380) if(MemoryEPD(NewHeader, AtLeast, 0x59CCA8)) {
    if EUDIf()(MemoryEPD(NewHeader, AtLeast, 0x59CCA8)):
        # (Line 1381) const NewPrevPtr, NewPrevEPD = cunitepdread_epd(NewHeader);
        NewPrevPtr, NewPrevEPD = List2Assignable([f_cunitepdread_epd(NewHeader)])
        # (Line 1382) const NewPrev_nxt = NewPrevEPD + 0x6C / 4;
        NewPrev_nxt = NewPrevEPD + 0x6C // 4
        # (Line 1383) const NewNextPtr, NewNextEPD = cunitepdread_epd(NewPrev_nxt);
        NewNextPtr, NewNextEPD = List2Assignable([f_cunitepdread_epd(NewPrev_nxt)])
        # (Line 1384) dwwrite_epd(NewPrev_nxt, ptr);
        f_dwwrite_epd(NewPrev_nxt, ptr)
        # (Line 1385) dwwrite_epd(prv, NewPrevPtr);
        f_dwwrite_epd(prv, NewPrevPtr)
        # (Line 1386) dwwrite_epd(nxt, NewNextPtr);
        f_dwwrite_epd(nxt, NewNextPtr)
        # (Line 1387) if(NewNextPtr >= 0x59CCA8) {
        if EUDIf()(NewNextPtr >= 0x59CCA8):
            # (Line 1388) dwwrite_epd(NewNextEPD + 0x68 / 4, ptr);
            f_dwwrite_epd(NewNextEPD + 0x68 // 4, ptr)
            # (Line 1389) }
            # (Line 1390) } else {
        EUDEndIf()
    if EUDElse()():
        # (Line 1391) dwwrite_epd(NewHeader, ptr);
        f_dwwrite_epd(NewHeader, ptr)
        # (Line 1392) dwwrite_epd(prv, 0);
        f_dwwrite_epd(prv, 0)
        # (Line 1393) dwwrite_epd(nxt, 0);
        f_dwwrite_epd(nxt, 0)
        # (Line 1394) }
        # (Line 1395) }
    EUDEndIf()
